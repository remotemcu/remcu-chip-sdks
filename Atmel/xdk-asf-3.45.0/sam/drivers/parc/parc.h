/**
 * \file
 *
 * \brief SAM4L PARC driver.
 *
 * Copyright (c) 2013-2018 Microchip Technology Inc. and its subsidiaries.
 *
 * \asf_license_start
 *
 * \page License
 *
 * Subject to your compliance with these terms, you may use Microchip
 * software and any derivatives exclusively with Microchip products.
 * It is your responsibility to comply with third party license terms applicable
 * to your use of third party software (including open source software) that
 * may accompany Microchip software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
 * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL MICROCHIP BE
 * LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL
 * LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
 * SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
 * POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE FULLEST EXTENT
 * ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY
 * RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
 * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 * \asf_license_stop
 *
 */
/*
 * Support and FAQ: visit <a href="https://www.microchip.com/support/">Microchip Support</a>
 */

#ifndef PARC_H_INCLUDED
#define PARC_H_INCLUDED

/**
 * \defgroup asfdoc_sam_drivers_parc_group SAM4L Parallel Capture (PARC) Driver
 *
 * This driver for Atmel&reg; | SMART ARM&reg;-based microcontrollers provides an interface for 
 * the configuration and management of the Parallel Capture module.
 *
 * The Parallel Capture module samples an external 8-bit bus with an external
 * input clock. It can be connected to a CMOS digital image sensor, an ADC,
 * a DSP synchronous port, etc.
 *
 * Devices from the following series can use this module:
 * - Atmel | SMART SAM4L
 *
 * The outline of this documentation is as follows:
 *  - \ref asfdoc_sam_drivers_parc_prerequisites
 *  - \ref asfdoc_sam_drivers_parc_module_overview
 *  - \ref asfdoc_sam_drivers_parc_special_considerations
 *  - \ref asfdoc_sam_drivers_parc_extra_info
 *  - \ref asfdoc_sam_drivers_parc_examples
 *  - \ref asfdoc_sam_drivers_parc_api_overview
 *
 *
 * \section asfdoc_sam_drivers_parc_prerequisites Prerequisites
 *
 * There are no prerequisites for this module.
 *
 *
 * \section asfdoc_sam_drivers_parc_module_overview Module Overview
 *
 * The Parallel Capture (PARC) module samples an external 8-bit bus with an external
 * input clock. It can be connected to a CMOS digital image sensor, an ADC, a DSP
 * synchronous port, etc.
 *
 * \subsection asfdoc_sam_drivers_parc_module_overview_features Features
 * The PARC module offers the following features:
 * - Captures 8-bit data with an external input clock
 * - Data captures can be concatenated to form 16-bit and 32-bit values
 * - Two external data enables PCEN1 and PCEN2
 * - Four data sample conditions:
 *    - When PCEN1 is high
 *    - When PCEN1 and PCEN2 are both high
 *    - When PCEN1 or PCEN2 are high
 *    - PC1EN1 and PCEN2 are both inactive i.e. data is sampled without condition
 * - Peripheral Direct Memory Access (DMA) is supported
 * - Peripheral events are supported
 *
 * \subsection asfdoc_sam_drivers_parc_module_overview_width Concatenated Data Capture
 * Captured data bytes are stored in the module's Receive Holding Register (RHR).
 * Concatenated data can also be stored in the RHR to make 16-bit or 32-bit
 * values, with the first byte received in the Least Significant Byte (LSB) position.
 * Refer to the diagram entitled "parallel capture waveforms" in the parc
 * chapter of the device-specific datasheet for more information.
 *
 *
 * \section asfdoc_sam_drivers_parc_special_considerations Special Considerations
 *
 * \subsection asfdoc_sam_drivers_parc_special_considerations_io I/O Lines
 * The PARC pins are multiplexed with other peripherals. The user application must
 * first configure the I/O Controller to yield control of the pins.
 *
 * \subsection asfdoc_sam_drivers_parc_special_considerations_power Power Management
 * The PARC module stops functioning when the system enters a sleep mode that
 * disables its clock.
 *
 * \subsection asfdoc_sam_drivers_parc_special_considerations_clocks Clocks
 * The PARC module's clock is generated by the Power Manager. It can be disabled
 * either manually via software or automatically when the system enters a sleep
 * mode that disables the clocks to the peripheral bus modules. For correct
 * behavior, the PARC module's clock frequency must be at least twice the
 * PCCK frequency.
 *
 * \subsection asfdoc_sam_drivers_parc_special_considerations_dma DMA
 * The PARC module's DMA handshake interface is connected to the Peripheral DMA
 * Controller (PDCA). Using the PARC module's DMA functionality requires the
 * PDCA to be configured first.
 *
 * \subsection asfdoc_sam_drivers_parc_special_considerations_irq Interrupt
 * The PARC interrupt request line is connected to the Nested Vectored Interrupt
 * Controller (NVIC). Using the PARC interrupt requires that the NVIC to be
 * configured first.
 *
 *
 * \section asfdoc_sam_drivers_parc_extra_info Extra Information
 *
 * For extra information, see \ref asfdoc_sam_drivers_parc_extra. This includes:
 *  - \ref asfdoc_sam_drivers_parc_extra_acronyms
 *  - \ref asfdoc_sam_drivers_parc_extra_dependencies
 *  - \ref asfdoc_sam_drivers_parc_extra_errata
 *  - \ref asfdoc_sam_drivers_parc_extra_history
 *
 * \section asfdoc_sam_drivers_parc_examples Examples
 *
 * For a list of examples related to this driver, see
 * \ref asfdoc_sam_drivers_parc_exqsg.
 *
 *
 * \section asfdoc_sam_drivers_parc_api_overview API Overview
 * @{
 */

 
#include <compiler.h>
#include <status_codes.h>

/// @cond
/**INDENT-OFF**/
#ifdef __cplusplus
extern "C" {
#endif
/**INDENT-ON**/
/// @endcond


#if (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__)
#if !defined(__DOXYGEN__)
extern struct parc_module *parc_module_instance;
struct parc_module;
#endif
/** PARC interrupt handler callback type. */
typedef void (*parc_callback_t)(const struct parc_module *const module_inst);
#endif

/** PARC sampling edge. */
enum parc_sampling_edge {
	/** Data capture occurs on the rising edge of PCCK. */
	PARC_RISING_EDGE = 0,
	/** Data capture occurs on the falling edge of PCCK. */
	PARC_FALLING_EDGE = 1,
};

/** PARC captured byte. */
enum parc_capture_mode {
	/** Bytes are captured when data is captured every cycle. */
	PARC_BOTH_CAPTURE = 0,
	/** Even bytes are captured when data is captured every two cycles. */
	PARC_EVEN_CAPTURE,
	/** Odd bytes are captured when data is captured every two cycles. */
	PARC_ODD_CAPTURE,
};

/** PARC sample mode. */
enum parc_smode {
	/** Data capture occurs with PCEN1 high. */
	PARC_SMODE_PCEN1_H = 0,
	/** Data capture occurs with PCEN1 and PCEN2 high. */
	PARC_SMODE_PCEN1_AND_PCEN2_H,
	/** Data capture occurs with either PCEN1 or PCEN2 high. */
	PARC_SMODE_PCEN1_OR_PCEN2_H,
	/** Data capture always occurs. */
	PARC_SMODE_ALWAYS,
};

/** PARC data Size. */
enum parc_data_size {
	/** PARC data transfer size is 8-bits. */
	PARC_DSIZE_BYTE = 0,
	/** PARC data transfer size is 16-bits. */
	PARC_DSIZE_HALFWORD = 1,
	/** PARC data transfer size is 32-bits. */
	PARC_DSIZE_WORD = 2,
};

/** PARC status. */
enum parc_status {
	PARC_STATUS_EN = PARC_SR_EN,		/**< PARC module enable/disable status. */
	PARC_STATUS_CS = PARC_SR_CS,		/**< PARC Capture mode enable/disable status. */
	PARC_STATUS_DRDY = PARC_SR_DRDY,	/**< Data is ready in the receive  holding register. */
	PARC_STATUS_OVR = PARC_SR_OVR,		/**< Overrun error. */
};

#if (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__)
/** PARC interrupt source. */
enum parc_interrupt_source {
	PARC_INTERRUPT_DRDY = PARC_SR_DRDY,	/**< Data ready interrupt. */
	PARC_INTERRUPT_OVR = PARC_SR_OVR,	/**< Data overrun interrupt. */
};

/** PARC callback type. */
enum parc_callback_type {
	/** Data ready callback. */
	PARC_CALLBACK_DATA_READY = 0,
	/** Data overrun callback. */
	PARC_CALLBACK_OVERRUN,
#if !defined(__DOXYGEN__)
	/** Callback count. */
	PARC_CALLBACK_N,
#endif
};
#endif /* (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__) */

/**
 * PARC configuration structure
 *
 * \note This structure should be initialized by the \ref parc_get_config_defaults()
 * function before being further modified by the user application.
 */
struct parc_config {
	/** Capture mode. */
	enum parc_capture_mode capture_mode;
	/** Sampling edge select. */
	enum parc_sampling_edge sampling_edge;
	/** Sampling mode. */
	enum parc_smode smode;
	/** Data size. */
	enum parc_data_size dsize;
};

/**
 * PARC driver structure.
 *
 * \note This structure should be initialized by the function \ref parc_init().
 */
struct parc_module {
	/** Base address of the PARC module. */
	Parc *hw;
	/** Pointer to the PARC configuration structure. */
	struct parc_config *parc_cfg;

#if (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__)
	/** Array to store callback functions (<b>for PARC driver use only</b>). */
	parc_callback_t callback[PARC_CALLBACK_N];
	/** Bitmask of callbacks registered (<b>for PARC driver use only</b>). */
	uint8_t registered_callback_mask;
	/** Bitmask of callbacks enabled/disabled (<b>for PARC driver use only</b>). */
	uint8_t enabled_callback_mask;
#endif /* (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__) */
};

enum status_code parc_init(
	struct parc_module *const module_inst,
	Parc *const hw,
	struct parc_config *const config);

enum status_code parc_set_config(
	struct parc_module *const module_inst,
	struct parc_config *config);

/**
 * \brief Initialize a PARC configuration structure to default values.
 *
 * Initializes the supplied PARC configuration structure to a set of known default
 * values.
 *
 * \note This function should be called to populate new instances of the
 * configuration structure before being further modified by the user application.
 *
 * The default configurations are:
 * - Capture every byte
 * - Sample the data bus on the rising edge of the PCCK input clock
 * - Sample data regardless of the levels of PCEN1 and PCEN2
 * - 8-bit data width
 *
 * \param[out] config Pointer to a PARC configuration structure
 */
static inline void parc_get_config_defaults(
		struct parc_config *const config)
{
	/* Validate parameters. */
	Assert(config);
	
	config->capture_mode = PARC_BOTH_CAPTURE;
	config->sampling_edge = PARC_RISING_EDGE;
	config->smode = PARC_SMODE_ALWAYS;
	config->dsize = PARC_DSIZE_BYTE;
}

/**
 * \brief Enable the PARC module.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The enable procedure status.
 * \retval STATUS_OK The enable procedure was successful
 */
static inline enum status_code parc_enable(
		struct parc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;
	parc_module_hw->PARC_CR = PARC_CR_EN;

#if PARC_CALLBACK_MODE == true
	/* enable interrupt*/
	NVIC_EnableIRQ(PARC_IRQn);
#endif
	return STATUS_OK;
}

/**
 * \brief Disable the PARC module.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The disable procedure status.
 * \retval STATUS_OK The disable procedure was successful
 */
static inline enum status_code parc_disable(
		struct parc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;
	parc_module_hw->PARC_CR = PARC_CR_DIS;

#if PARC_CALLBACK_MODE == true
	/* disable interrupt*/
	NVIC_DisableIRQ(PARC_IRQn);
#endif
	return STATUS_OK;
}

/**
 * \brief Start a PARC conversion
 *
 * \param[in] module_inst Driver structure pointer
 */
static inline void parc_start_capture(
		struct parc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;

	parc_module_hw->PARC_CR = PARC_CR_START;
}

/**
 * \brief Stop a PARC conversion.
 *
 * \param[in] module_inst Driver structure pointer
 */
static inline void parc_stop_capture(
		struct parc_module *const module_inst)
{
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;

	parc_module_hw->PARC_CR = PARC_CR_STOP;
}

/**
 * \brief Get the PARC module's current status.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The PARC module's current status as a \ref parc_status "bitmask".
 * \retval PARC_STATUS_EN   PARC is enabled
 * \retval PARC_STATUS_CS   PARC capture status
 * \retval PARC_STATUS_DRDY PARC data ready
 * \retval PARC_STATUS_OVR  PARC overrun
 */
static inline uint32_t parc_get_status(
		struct parc_module *const module_inst)
{
	Parc *const parc_module_hw = module_inst->hw;
	return parc_module_hw->PARC_SR;
}

/**
 * \brief Check the data ready status of PARC.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The PARC data ready status.
 * \retval false Captured data is not ready
 * \retval true  Captured data is ready
 */
static inline bool parc_is_data_ready(
		struct parc_module *const module_inst)
{
	Parc *const parc_module_hw = module_inst->hw;
	return ((parc_module_hw->PARC_SR & PARC_SR_DRDY) != 0);
}

/**
 * \brief Clear PARC interrupt(s) status flag.
 *
 * \param[in] module_inst Driver structure pointer
 * \param[in] status      A bitmask of \ref parc_status "interrupt sources" to clear
 *
 * \return The clear interrupt operation status.
 * \retval STATUS_OK The interrupt was cleared successfully
 */
static inline enum status_code parc_clear_status(
		struct parc_module *const module_inst,
		const uint32_t status)
{
	/* Sanity check arguments*/
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;

	uint32_t int_flags = 0;

	/*check for PARC data ready*/
	if(status & PARC_STATUS_DRDY){
		int_flags |= PARC_ICR_DRDY;
	}
	/*check for PARC overrun*/
	if(status & PARC_STATUS_OVR){
		int_flags |= PARC_ICR_OVR;
	}

	/*clear interrupt flags*/
	parc_module_hw->PARC_ICR = int_flags;

	return STATUS_OK;
}

/**
 * \brief Get PARC data.
 *
 * \param[in]  module_inst Driver structure pointer
 * \param[out] data        Pointer to store the captured data in
 *
 * \return The status of the PARC read data request.
 * \retval STATUS_OK        Captured data was read successfully
 * \retval STATUS_ERR_BUSY  Captured data is not ready
 */
static inline enum status_code parc_read(
		struct parc_module *const module_inst,
		uint32_t *data)
{
	Assert(module_inst);
	Assert(module_inst->hw);
	Assert(data);

	if(!(parc_get_status(module_inst) & PARC_SR_DRDY)){
		/* Captured data not ready*/
		return STATUS_ERR_BUSY;
	}

	Parc *const parc_module_hw = module_inst->hw;
	*data = parc_module_hw->PARC_RHR;

	parc_clear_status(module_inst, PARC_STATUS_DRDY);
	return STATUS_OK;
}

#if (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__)
/**
 * \brief Enable PARC interrupt(s).
 *
 * \param[in] module_inst Driver structure pointer
 * \param[in] source      Bitmask of \ref parc_interrupt_source "interrupt sources" to enable
 */
static inline void parc_enable_interrupts(
		struct parc_module *const module_inst,
		enum parc_interrupt_source source)
{
	/* Sanity check arguments*/
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;

	parc_module_hw->PARC_IER = source;
}

/**
 * \brief Disable PARC interrupt(s).
 *
 * \param[in] module_inst Driver structure pointer
 * \param[in] source      Bitmask of \ref parc_interrupt_source "interrupt sources" to disable
 */
static inline void parc_disable_interrupts(
		struct parc_module *const module_inst,
		enum parc_interrupt_source source)
{
	/* Sanity check arguments*/
	Assert(module_inst);
	Assert(module_inst->hw);

	Parc *const parc_module_hw = module_inst->hw;

	parc_module_hw->PARC_IDR = source;
}

/**
 * \brief Get the PARC interrupt mask.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The PARC interrupt mask.
 */
static inline uint32_t parc_read_interrupt_mask(
	struct parc_module *const module_inst)
{
	Parc *const parc_module_hw = module_inst->hw;
	return parc_module_hw->PARC_IMR;
}
#endif /* (PARC_CALLBACK_MODE == true) || defined(__DOXYGEN__) */

/**
 * \brief Enable the PARC events mode.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The status of the event enable operation.
 * \retval STATUS_OK The event was enabled successfully
 */
static inline enum status_code parc_enable_events(
	struct parc_module *const module_inst)
{
	Parc *const parc_module_hw = module_inst->hw;
	parc_module_hw->PARC_CFG |= PARC_CFG_EMODE;

	return STATUS_OK;
}

/**
 * \brief Disable the PARC events mode.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The status of the event disable operation.
 * \retval STATUS_OK The event was disabled successfully
 */
static inline enum status_code parc_disable_events(
	struct parc_module *const module_inst)
{
	Parc *const parc_module_hw = module_inst->hw;
	parc_module_hw->PARC_CFG &= ~(PARC_CFG_EMODE);

	return STATUS_OK;
}

/**
 * \brief Get the PARC module version.
 *
 * \param[in] module_inst Driver structure pointer
 *
 * \return The PARC module version.
 */
static inline uint32_t parc_get_version(
		struct parc_module *const module_inst)
{
	Parc *const parc_module_hw = module_inst->hw;
	return parc_module_hw->PARC_VERSION;
}

/// @cond
/**INDENT-OFF**/
#ifdef __cplusplus
}
#endif
/**INDENT-ON**/
/// @endcond

 /** @} */

/**
 * \page asfdoc_sam_drivers_parc_extra Extra Information for Parallel Capture
 *
 * \section asfdoc_sam_drivers_parc_extra_acronyms Acronyms
 * Below is a table listing the acronyms used in this module, along with their
 * intended meanings.
 *
 * <table>
 *  <tr>
 *      <th>Acronym</th>
 *      <th>Definition</th>
 *  </tr>
 *  <tr>
 *      <td>ADC</td>
 *      <td>Analog to Digital Converter</td>
 * </tr>
 *  <tr>
 *      <td>CMOS</td>
 *      <td>Complementary Metal-Oxide-Semiconductor</td>
 * </tr>
 *  <tr>
 *      <td>DMA</td>
 *      <td>Direct Memory Access</td>
 * </tr>
 *  <tr>
 *      <td>DSP</td>
 *      <td>Digital Signal Processor</td>
 * </tr>
 *  <tr>
 *      <td>I/O</td>
 *      <td>Input/Output</td>
 * </tr>
 *  <tr>
 *      <td>LSB</td>
 *      <td>Least Significant Byte</td>
 * </tr>
 *  <tr>
 *      <td>NVIC</td>
 *      <td>Nested Vectored Interrupt Controller</td>
 * </tr>
 *  <tr>
 *      <td>PCCK</td>
 *      <td>Parallel Capture Clock</td>
 * </tr>
 *  <tr>
 *      <td>PDCA</td>
 *      <td>Peripheral DMA Controller</td>
 * </tr>
 *  <tr>
 *      <td>RHR</td>
 *      <td>Receive Holding Register</td>
 * </tr>
 *  <tr>
 *      <td>QSG</td>
 *      <td>Quick Start Guide</td>
 * </tr>
 * </table>
 *
 *
 * \section asfdoc_sam_drivers_parc_extra_dependencies Dependencies
 * This driver has the following dependencies:
 *
 *  - None
 *
 *
 * \section asfdoc_sam_drivers_parc_extra_errata Errata
 * There are no errata related to this driver.
 *
 *
 * \section asfdoc_sam_drivers_parc_extra_history Module History
 * An overview of the module history is presented in the table below, with
 * details on the enhancements and fixes made to the module since its first
 * release. The current version of this corresponds to the newest version in
 * the table.
 *
 * <table>
 *	<tr>
 *		<th>Changelog</th>
 *	</tr>
 *	<tr>
 *		<td>Initial document release</td>
 *	</tr>
 * </table>
 */
 
/**
 * \page asfdoc_sam_drivers_parc_exqsg Examples for Parallel Capture
 *
 * This is a list of the available Quick Start Guides (QSGs) and example
 * applications for \ref asfdoc_sam_drivers_parc_group. QSGs are simple examples with
 * step-by-step instructions to configure and use this driver in a selection of
 * use cases. Note that a QSG can be compiled as a standalone application or be
 * added to the user application.
 *
 *  - \subpage asfdoc_sam_drivers_parc_qsg
 *  - \subpage asfdoc_sam_drivers_parc_example
 *
 * \page asfdoc_sam_drivers_parc_document_revision_history Document Revision History
 *
 * <table>
 *	<tr>
 *		<th>Doc. Rev.</td>
 *		<th>Date</td>
 *		<th>Comments</td>
 *	</tr>
 *	<tr>
 *		<td>42297B</td>
 *		<td>07/2015</td>
 *		<td>Updated title of application note and added list of supported devices</td>
 *	</tr>
 *	<tr>
 *		<td>42297A</td>
 *		<td>05/2014</td>
 *		<td>Initial document release</td>
 *	</tr>
 * </table>
 *
 */
 
/**
 * \page asfdoc_sam_drivers_parc_qsg Quick Start Guide for the PARC driver
 *
 * This is the quick start guide for the \ref asfdoc_sam_drivers_parc_group, with
 * step-by-step instructions on how to configure and use the driver for
 * a specific use case.
 *
 * The use cases contain several code fragments. The code fragments in the
 * steps for setup can be copied into a custom initialization function, while
 * the steps for usage can be copied into, e.g. the main application function.
 *
 * \section asfdoc_sam_drivers_parc_qsg_use_cases Use Cases
 * - \ref asfdoc_sam_drivers_parc_qsg_basic_use_case
 *
 * \section asfdoc_sam_drivers_parc_qsg_basic_use_case PARC Basic Use Case
 *
 * This use case demonstrates how to use the PARC module on SAM4L. In this use
 * case the PARC module is configured as:
 * - Capture every byte
 * - Sample the data bus on the rising edge of the PCCK input clock
 * - Sample data regardless of the levels of PCEN1 and PCEN2
 * - 8-bit data width
 *
 * \section asfdoc_sam_drivers_parc_qsg_basic_setup Setup Steps
 *
 * \subsection asfdoc_sam_drivers_parc_qsg_basic_prereq Prerequisites
 *
 * This module requires the following service:
 * - \ref clk_group "System clock (sysclk)"
 *
 * \subsection asfdoc_sam_drivers_parc_qsg_basic_setup_code Setup Code Example
 *
 * Add the following to the main loop or a setup function:
 * \snippet parc_example.c parc_variables
 * \snippet parc_example.c parc_get_defaults
 * \snippet parc_example.c parc_init_enable_and_start
 *
 * \subsection asfdoc_sam_drivers_parc_qsg_basic_setup_workflow Basic Setup Workflow
 *
 * -# Initialize and configure PARC:
 * \snippet parc_example.c parc_get_defaults
 * \snippet parc_example.c parc_init_enable_and_start_1
 * -# Enable the PARC module and start capture:
 * \snippet parc_example.c parc_init_enable_and_start_2
 *
 * \section asfdoc_sam_drivers_parc_qsg_basic_usage PARC Basic Usage
 *
 * \subsection asfdoc_sam_drivers_parc_qsg_basic_usage_code Basic Usage Code
 *
 * We can poll the data ready status and then read it once capture has finished:
 * \verbatim
    uint32_t captured_data;

    while (!parc_is_data_ready(&module_inst)) {
	    }
    parc_read(&module_inst, &captured_data); \endverbatim
 *
 * We can enable the data ready interrupt and install a callback function to perform
 * a custom task:
 * \verbatim
    parc_register_callback(&module_inst,
        (parc_callback_t)parc_complete_callback, PARC_CALLBACK_DATA_READY);
    parc_enable_interrupts(&module_inst, PARC_INTERRUPT_DRDY);
    parc_enable_callback(&module_inst, PARC_CALLBACK_DATA_READY);
    parc_start_capture(&module_inst);

    // The callback function example.
    static void parc_complete_callback(
	    struct parc_module *const module)
    {
      callback_data_ready = true;
      parc_read(module, &captured_data);
    } \endverbatim
 */
#endif  /* PARC_H_INCLUDED */

